// Copyright(c) 2004, Webb Research Corporation, ALL RIGHTS RESERVED
/* dba2_glider_data.cc

Reads dinkum binary ascii data from stdin (output of dbd2asc)
and writes two matlab files (your filenames will vary):

    zippy_2001_104_21_0_gld.m
    zippy_2001_104_21_0_gld.dat

These files are processed by glider_data.m

At the end of this file is an example .m and .dat file

14-Jan-04 trout.r@comcast.net Initial file copied from dba2_orig_matlab.cc
							  and modified to output .m and .dat files
							  consumed by glider_data.m
21-Jan-04 tc@DinkumSoftware.com Removed unused var mission_start_secs_since_eden
                                detected on linux compile
27-Jan-04 trout.r@comcast.net Made format changes to output .m file and renamed
                              output .m and .dat files to avoid overwriting the
                              .m and .dat files generated by processing.sbd
                              and .dbd files with the same base name.
2006-03-13 fnj@DinkumSoftware.com    In gen_the_m_file: changed max_length from 30 to 63.
                                     In Matlab 6.5.1, variable names may be of any length,
                                     and are significant up to 63 characters.  There are
                                     starting to be masterdata sensor names that are not
                                     disambiguated until after the 30th character.
                                     Note: not sure why we should truncate them at all here.

Table of contents
    main
    base_matlab_filename Chooses * of *.m, *.dat
    gen_the_m_file       Makes the *.m file

*/

#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include "dbd_asc_header.h"
#include "dbd_sensor_value_collection.h"

using namespace dinkum_binary_data ;

static string base_matlab_filename(const dbd_asc_header & hdr) ;

static void gen_the_m_file(const dbd_asc_header & hdr) throw (dbd_error) ;
                           
                           
#pragma warn_unusedarg off
int main(int argc, char* argv[] )
{
  // What we say when we get an error
  const string error_msg_leadin = "ERROR prog: dba2_glider_data: " ;

  try
    {
      // Read in the ascii header
      dbd_asc_header  hdr(cin) ;

      // Produce the *.m file
      gen_the_m_file(hdr) ;


      // Pick the *.dat filename
      string dat_filename = base_matlab_filename(hdr) ;
      dat_filename += ".dat" ;

      // Open up the *.dat file
      // We just have to copy data lines
      ofstream dat(dat_filename.c_str()) ;
      if ( !dat )
        {
          ostringstream emsg ;
          emsg << "Couldn't open filename: " << dat_filename ;
          throw ( dbd_error(emsg) ) ;
        }

      // Copy the rest of the lines
      while(true)
      {
        // Get a char and quit on EOF
        char c ;
        cin.get(c) ; // read next input char
        if (cin.eof() ) break ;

        dat << c ;  // output it
      }

      // all done
    }
  catch(dbd_error e)
    {
      cerr << error_msg_leadin << e.get_err_msg() << endl ; 
    }
  catch(...)
    {   cerr << error_msg_leadin << "Unknown Exception Caught" << endl ;
    }



  // Life is good
  return 0 ;
}
#pragma warn_unusedarg on


string base_matlab_filename(const dbd_asc_header & hdr)
{
  // We start with the same filename as the *.dbd file
  string m_filename = hdr.filename ;

  // Tack on the filename extension, so dbd, sbd, and gld files have
  // unique filenames
  m_filename = m_filename + "-" + hdr.filename_extension + "-gld" ;

  // Change all the -'s to _'s cause matlab thinks
  // they mean subtraction
  const char frm_c = '-' ;
  const char to_c  = '_' ; 

  int indx = 0 ;    // Position of the - we want to replace
  while ( (indx = m_filename.find( frm_c, indx)) != string::npos )
    {
      // We found a char, replace it
      // The 1's are the number of chars to replace
      m_filename.replace ( indx, 1, 1, to_c) ;
    }

  // Give them answer
  return m_filename ;

}





/* ------------------ Examples --------------------------------
------------------ z0110203.m ---------------------------------
function zippy_2001_104_21_0_gld
% column indices for Glider data
% binary vehicle file: z0110203.obd
% tabular ascii file:  z0110203.dat

% OS-9 process start time: 2001/04/12 17:21:12 GMT     
% structure creation time: 12 Apr 2001 17:21:11 Z     

sensor_lookup = struct(...
'f_max_working_depth',1 ,...
'f_nominal_dive_rate',2 ,...
'f_nominal_pitch',3 ,...
'f_enable_picozoom',4 ,...
'f_auto_picozoom_heap_reqd',5 ,...

        ....... etc .......

'm_disk_usage',600 ,...
'm_disk_free',601 ,...
'x_disk_files_removed',602 ,...
'u_freewave_data_rate',603 ,...
'u_iridium_data_rate',604);
data = load('z0110203.dat')

*/

/* gen_the_m_file

Produces a file similar to above.

The filename is echoed to stdout.

2006-03-13 fnj@DinkumSoftware.com    Changed max_length from 30 to 63.
*/

void gen_the_m_file(const dbd_asc_header & hdr) throw (dbd_error)
{

  // Pick the filename
  // We have to change all the - to _ cause matlab thinks its a subtraction
  // zippy_2001_104_21_0.m
  const string base_filename = base_matlab_filename(hdr) ;

  string m_filename = base_filename ;
  m_filename += ".m" ;
  
  // Open up the file
  ofstream mf(m_filename.c_str() ) ;
  if ( !mf )
    {
      ostringstream emsg ;
      emsg << "Couldn't open filename: " << m_filename ;
      throw ( dbd_error(emsg) ) ;
    }

  // Blow out the fixed stuff
  mf << "% column indices for Glider data"                    << endl ;
  mf << "% binary vehicle file: " << hdr.filename_label       << endl ;
  mf << "% tabular ascii file:  " << base_filename  << ".dat" << endl ;
  mf << "global sensor_lookup"                                << endl ;
  mf << "global data"                                         << endl ;
  mf << "run_name = '" << hdr.filename_label << "';"          << endl ;
  mf << "% OS-9 process start time: " << hdr.fileopen_time    << endl ;
  mf << "% structure creation time: " << hdr.fileopen_time    << endl ;
  
  /* Create Structure of sensor names and column reference
  for the data file. This structure is used in 
  Matlab data processing tools.
  */
  const int max_length = 63 ;
  int i ;
  mf << "sensor_lookup = struct(..."<< endl ;
  for (i = 0 ; i < hdr.sensors_per_cycle - 1 ; i++)
  {
    string name_copy(hdr.sensor_list[i].name) ;
    if (name_copy.length() > max_length)
    {
      name_copy.erase(max_length, name_copy.length() - max_length) ;
    }
    mf << "'" << name_copy << "'," << i+1 << " ,..." << endl ;
  }
  mf << "'" << hdr.sensor_list[i].name << "'," << i+1 ;

  if (hdr.hasOptionalKeys())
  { // continue to add items to matlab struct
    mf << " ,..." << endl ;
    // Write segment filenames to matlab struct
    hdr.segment_filenames_to_matlab_struct(mf, false) ;
    
    // Write required header keys and values to matlab struct
    hdr.required_keys_to_matlab_struct(mf, false) ;
  
    // Write optional header keys and values to matlab struct
    hdr.optional_keys_to_matlab_struct(mf, true) ;
  }
  else
  {  // end of matlab struct
    mf << ");" << endl ;
  }

  // finish up
  mf << "data = load('"  << base_filename << ".dat');" << endl ;


  // Tell um the name
  cout << m_filename << endl ;

  // file gets closed as it is destructed

}


 /*
>------------------ z0110203.dat ---------------------------------
>  There is one line per cycle
>  all the sensor values (in order) separated by spaces.
>-----------------------------------------------------------------
30	2	9.8709606e+08	2.316	0.07	.......
NaN	NaN	9.8709606e+08	5.2750001	NaN	.......


*/
